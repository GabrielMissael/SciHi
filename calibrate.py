import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sb
import scipy.optimize as op

def Calibrate(PATHS,dates,calibration = 'Chisq'):
    """
    Returns the Gain K for the calibration selected, also returns 
    T_gsm,T_meas and T_std, the theoretical gsm temperature, the measured
    and its standard deviation respectively.
    
    Parameters:
    PATHS: Path of the data to calibrate, if JNC calibration is chosen this 
           variable must be a tuple in the form (DATA_PATH,KJNC_PATH).
           
           KJNC_PATH must be the path to the Kjnc generated by the filter function 
           in the filtering process.
        
        
    dates: 4 dim Array, must contain the initial date for the measured data,
           the final date for the measured data, initial date for the 
           theoretical data and final date for theoretical data.

           (Date_data0,Date_data1,Date_teo0,Date_teo1)
            
    Optional:
    calibration: Choose between 'Chisq' or 'JNC', it defines how the data
                 calibration will be done.
    
    
    RETURNS: 4 variables, K,T_gsm,T_meas,T_std
    """
    if isinstance(PATHS,(tuple)):
        PATH = PATHS[0]
        PATH_JNC = PATHS[1]
    else:
        PATH = PATHS
    
    Temps = pd.read_hdf(PATH)
    Date_data0,Date_data1,Date_teo0,Date_teo1 = dates
    temp = Temps.loc[:,Date_data0:Date_data1]
    data = temp.values
    data_gsm = pd.read_hdf('calibration/Tgsm.hdf5')
    data_gsm = data_gsm.loc[:,Date_teo0:Date_teo1]
    T_gsm = data_gsm.values
    freqs = data_gsm.index.values
    index = Temps.index.values
    
    if calibration=='JNC':
        Kjnc = pd.read_hdf(PATH_JNC)
        Temps = Kjnc*Temps
    
    freq_bins = []
    for f in freqs:
        mask = (index>=f)&(index<f+1)
        freq_bins.append(np.mean(temp[mask]))
    Temp_binfreq = np.array(freq_bins)
    
    bins = int(np.shape(Temp_binfreq)[1]/25. +1)
    # Data binning in time, 25 is because every 25 data is 5 mins (Aprox 12 secs between data)
    T_meas = np.zeros(np.shape(T_gsm))
    T_std = np.zeros(np.shape(T_gsm))
    for i in range(bins):
        T_meas[:,i] = np.mean(Temp_binfreq[:,25*i:25*(i+1)], axis =1)
        T_std[:,i] = np.std(Temp_binfreq[:,25*i:25*(i+1)], axis =1)
    
    if calibration=='Chisq':
        def Chisq(k,Tmeas,Tgsm, error):
            Chi = (Tgsm- k*Tmeas/1.e19)**2./(error/1.e19)**2.
            return sum(Chi)
        fun = lambda *args: Chisq(*args)
        
        K = np.zeros(len(freqs))
        for i in range(len(freqs)):
            K[i] = op.minimize(fun,1,args=(T_meas[i,:],T_gsm[i,:],T_std[i,:])).x[0]
        K = K*1e-19
    elif calibration =='JNC':
        K_jnc = Kjnc.loc[:,Date_data0:Date_data1]
        
        freq_bins = []
        for f in freqs:
            mask = (index>=f)&(index<f+1)
            freq_bins.append(np.mean(K_jnc[mask]))
        Kjnc_binfreq = np.array(freq_bins)
        K_meas = np.zeros(np.shape(T_gsm))
        
        for i in range(bins):
            K_meas[:,i] = np.mean(Kjnc_binfreq[:,25*i:25*(i+1)], axis =1)
        K = np.mean(K_meas,axis=1)

    Tgsm = np.mean(T_gsm,axis=1)
    Tmeas = np.mean(T_meas,axis=1)
    Tstd = np.mean(T_std,axis=1)
    return K,Tgsm,Tmeas,Tstd

def Check_quality(PATH,dates,savepath=False):
    """
    Function for plotting the desired interval data for 
    visual check of quality.
    
    Parameters:
    PATHS: Path of the data to check.
    dates: 2 dim Array, must contain the initial and final date
           of the data to check.
           
    Optional: 
    savepath: Path to save the figure
    """
    Temps = pd.read_hdf(PATH)
    Temps.index = Temps.index.values.round(2)
    Date_0,Date_1 = dates
    temp = Temps.loc[:,Date_0:Date_1]
    sb.heatmap(np.log10(temp), cmap='YlGnBu', yticklabels=400)
    plt.xlabel('Days')
    plt.ylabel('Frequency (MHz)')
    if savepath != False:
        plt.savefig(savepath+'data_%s_%s.png'%(Date_0,Date_1),bbox_inches='tight')
    plt.show()
    
    